#!/usr/bin/env node
// Generated by LiveScript 1.3.1
(function(){
  var docopt, _, ref$, cat, mkdir, rm, exec, v, uid, Promise, asyncrepl, modulePath, fs, doc, getOption, o, targetMode, FILE, f, src, cwd, prepare, replaceCode, codeRegex, tmpdir, matchArray, promiseArray, par, promiseWhile, promisedReplace;
  docopt = require('docopt').docopt;
  _ = require('lodash');
  ref$ = require('shelljs'), cat = ref$.cat, mkdir = ref$.mkdir, rm = ref$.rm, exec = ref$.exec;
  v = require('verbal-expressions');
  uid = require('uid');
  Promise = require('bluebird');
  asyncrepl = require('async-replace');
  modulePath = "";
  fs = require('fs');
  doc = "Usage:\n    exemd FILE [ -p | --pdf ] [ -r | --raw ] \n    exemd -h | --help \n\nOptions:\n    -p, --pdf   Generate a pdf\n    -r, --raw   Unfold and execute blocks, generate raw markdown\n    -h, --help  \n\nArguments: \n    FILE       markdown file name.\n";
  getOption = function(a, b, def, o){
    if (!o[a] && !o[b]) {
      return def;
    } else {
      return o[b];
    }
  };
  o = docopt(doc);
  if (o['--pdf'] || o['-p']) {
    targetMode = 'pdf';
  } else {
    if (o['--raw'] || o['-r']) {
      targetMode = 'raw';
    } else {
      targetMode = 'html';
    }
  }
  FILE = o['FILE'];
  f = cat(FILE);
  src = __dirname;
  cwd = process.cwd();
  prepare = function(){
    var dirname;
    dirname = cwd + "/tmp" + uid(7);
    mkdir(dirname);
    return dirname;
  };
  replaceCode = curry$(function(tmpdir, m, lang, params, code, offset, string, done){
    var process, opts, block;
    process = require(modulePath + "exemd-" + lang).process;
    opts = {};
    opts.targetMode = targetMode;
    opts.params = params;
    opts.orig = m;
    opts.tmpdir = tmpdir;
    block = code;
    return process(block, opts).then(function(it){
      return done(null, it);
    }, function(it){
      return done(it, null);
    });
  });
  codeRegex = v().then("```").anythingBut("{").then("{").beginCapture().word().endCapture().anythingBut("!").then("!").beginCapture().anythingBut("}").endCapture().then("}").beginCapture().anythingBut("```").endCapture().then("```");
  tmpdir = prepare();
  matchArray = [];
  promiseArray = [];
  par = curry$(function(regex, myAsyncReplace, string){
    return (function(lstring){
      return new Promise(function(res, rej){
        return asyncrepl(lstring, regex, myAsyncReplace, function(err, result){
          if (lstring === result) {
            return rej(lstring);
          } else {
            return res(result);
          }
        });
      });
    }.call(this, string));
  });
  promiseWhile = function(init, action){
    var val;
    val = init;
    return new Promise(function(res, rej){
      var loop_;
      loop_ = function(it){
        return action(it).delay(1).then(loop_).caught(res);
      };
      return process.nextTick(function(){
        return loop_(init);
      });
    });
  };
  promisedReplace = function(regex, myAsyncReplace, string){
    return promiseWhile(string, par(regex, myAsyncReplace));
  };
  promisedReplace(codeRegex, replaceCode(tmpdir), f).then(function(it){
    var tmpMarkdown;
    if (targetMode === 'raw') {
      return console.log(it);
    } else {
      if (targetMode === 'html') {
        tmpMarkdown = tmpdir + "/" + uid(7) + ".md";
        it.to(tmpMarkdown);
        return exec("pandoc -s " + tmpMarkdown);
      }
    }
  }).done(function(){
    return rm('-rf', tmpdir);
  });
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
